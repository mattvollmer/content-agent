import * as ai0 from "ai";
import { AsyncIterableStream, InferUIMessageChunk, Tool, ToolSet, UIDataTypes, UIMessage, UIMessagePart, UITools } from "ai";

//#region src/api/chat.d.ts
interface Chat {
  readonly id: string;
}
interface MessageOptions {
  /**
   * behavior of the chat when sending this message.
   *
   * - "enqueue" will add messages to the chat and start the chat eventually.
   * - "interrupt" will interrupt the chat if running and send messages.
   * - "append" will add messages to the chat.
   */
  readonly behavior?: "enqueue" | "interrupt" | "append";
}
interface Message<METADATA = unknown, DATA_TYPES extends UIDataTypes = UIDataTypes, TOOLS extends UITools = UITools> {
  readonly role: UIMessage["role"];
  readonly parts: UIMessagePart<DATA_TYPES, TOOLS>[];
  readonly metadata?: METADATA;
}
declare const chat: Readonly<{
  upsert: (id: string) => Promise<Chat>;
  message: (id: string, message: Message, options?: MessageOptions) => Promise<void>;
}>;
//#endregion
//#region src/api/tools.d.ts
/**
 * ToolWith is a tool that supports the "with" method.
 *
 * @param CONTEXT The context type.
 * @param TOOL The tool type.
 * @returns The tool with the given context.
 */
type ToolWith<CONTEXT, TOOL extends Tool> = TOOL & {
  with(context: CONTEXT): TOOL;
};
/**
 * Tools are helpers for managing tools.
 */
declare const tools: {
  /**
   * with adds context to a set of tools that supports the "with" method.
   *
   * @param context
   * @param tools
   * @returns
   */
  with<const TOOLS extends ToolsWithContext>(tools: TOOLS, context: ContextFromTools<TOOLS>): { [K in keyof TOOLS]: Tool };
  /**
   * prefix adds a prefix to all the tools in a tool set.
   *
   * @param tools The tool set to prefix.
   * @param prefix The prefix to add to the tools.
   * @returns The prefixed tool set.
   */
  prefix(tools: ToolSet, prefix: string): ToolSet;
};
type ToolsWithContext = Record<string, Tool & {
  with(context: unknown): Tool;
}>;
type ContextFromTools<TOOLS extends ToolsWithContext> = TOOLS[keyof TOOLS] extends {
  with(context: infer C): any;
} ? C : never;
//#endregion
//#region src/api/storage.d.ts
/**
 * Storage allows agents to persist data.
 * Every agent has it's own persistent storage namespace.
 */
declare const storage: Readonly<{
  kv: Readonly<{
    get: (key: string) => Promise<string | undefined>;
    set: (key: string, value: string) => Promise<void>;
    del: (key: string) => Promise<void>;
  }>;
}>;
//#endregion
//#region src/api/index.d.ts
/**
 * SendMessagesResponse is the response of the sendMessages function.
 * It can be a stream of messages or an arbitrary response.
 */
type SendMessagesResponse = {
  toUIMessageStream(): AsyncIterableStream<InferUIMessageChunk<UIMessage>>;
} | Response | ReadableStream<InferUIMessageChunk<UIMessage>>;
/**
 * SendMessagesOptions is the options for the sendMessages function.
 */
interface SendMessagesOptions<MESSAGE extends UIMessage = UIMessage> {
  /**
   * Messages are all messages for the history of the chat.
   * It is the user's responsibility to manage context for the chat.
   */
  readonly messages: MESSAGE[];
  /**
   * Chat is the associated chat for the messages.
   */
  readonly chat: Chat;
  /**
   * abortSignal can be used to terminate streaming operations
   * immediately when the streaming request ends.
   */
  readonly abortSignal?: AbortSignal;
}
interface Agent<MESSAGE extends UIMessage = UIMessage> {
  /**
   * sendMessages is called when the agent is streaming chat messages.
   * This is invoked on chat creation, and can be programatically
   * invoked at any time with `blink.chat.message`.
   */
  sendMessages(options: SendMessagesOptions<MESSAGE>): Promise<SendMessagesResponse> | SendMessagesResponse;
  /**
   * onRequest is called when the agent receives a request.
   * This is for handling webhooks, or incoming client payloads
   * that warrant a response.
   *
   * @param request The request received by the agent.
   * @returns A response to the request. If void, the agent will
   *          respond with a 404.
   */
  onRequest?(request: Request): Promise<Response | void>;
}
/**
 * AgentDefaultExport is the expected default export of a compiled agent.
 * All routing logic is handled by the agent function.
 *
 * This maximizes flexibility over the agent's behavior -
 * allowing users to add arbitrary routing logic to the agent.
 */
type AgentDefaultExport = {
  readonly version: "v0";
  fetch: (request: Request) => Promise<Response> | Response;
  readonly supportsRequests?: boolean;
};
/**
 * agent is the main function to create a Blink agent.
 *
 * @param agent
 * @returns
 */
declare function agent<MESSAGE extends UIMessage = UIMessage>(agent: Agent<MESSAGE>): AgentDefaultExport;
type StreamResponseFormat = "ui-message" | "openai-chat" | "openai-response" | "anthropic" | "google" | "xai";
declare function withResponseFormat(response: Response, format: StreamResponseFormat): Response;
declare const _default: {
  agent: typeof agent;
  chat: Readonly<{
    upsert: (id: string) => Promise<Chat>;
    message: (id: string, message: Message, options?: MessageOptions) => Promise<void>;
  }>;
  storage: Readonly<{
    kv: Readonly<{
      get: (key: string) => Promise<string | undefined>;
      set: (key: string, value: string) => Promise<void>;
      del: (key: string) => Promise<void>;
    }>;
  }>;
  tools: {
    with<const TOOLS extends {
      [x: string]: ai0.Tool & {
        with(context: unknown): ai0.Tool;
      };
    }>(tools: TOOLS, context: ContextFromTools<TOOLS>): { [K in keyof TOOLS]: ai0.Tool };
    prefix(tools: ai0.ToolSet, prefix: string): ai0.ToolSet;
  };
};
//#endregion
export { Agent, AgentDefaultExport, Chat, ContextFromTools, Message, MessageOptions, SendMessagesOptions, SendMessagesResponse, StreamResponseFormat, ToolWith, agent, chat, _default as default, storage, tools, withResponseFormat };